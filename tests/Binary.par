type Tree<t> = recursive either {
    .branch (self) self,
    .leaf t,
}

type Trees<t> = recursive either {
  .b0 self,
  .b1 (Tree<t>) self,
  .e Tree<t>,
}

dec Trees.Merge : [type t] [Trees<t>] [t] Trees<t>
def Trees.Merge = [type t] [trees] [t]
  let t : Tree<t> = .leaf t in
  trees.begin.case {
    .b0 x => .b1(t) x,
    .b1(u) x => let t = .branch(u) t in .b0 x.loop,
    .e u => .b0 .e .branch(u) t,
  }

dec Trees.Flatten : [type t] [Trees<t>] Tree<t>
def Trees.Flatten = [type t] [trees]
  trees.begin.case {
    .b0 x => x.loop,
    .b1(t) x =>
      x.begin.case {
        .b0 x => x.loop,
        .b1(u) x =>
          let t = .branch(u) t in
          x.loop,
        .e u => .branch(u) t,
      },
    .e t => t,
  }

dec ListToTree : [type t] [t] [List<t>] Tree<t>
def ListToTree = [type t] [i] [list]
  let trees : Trees<t> = .e .leaf i in
  let trees : Trees<t> = list.begin.case {
    .item(t) x =>
      let trees = Trees.Merge(type t)(trees, t) in
      x.loop,
    .end! => trees,
  } in
  Trees.Flatten(type t)(trees)

dec ChoiceLoop: [type t] [List<t>] [List<t>] recursive choice {
	.left => either { .end List<t>, .item (t) self },
	.right => either { .end List<t>, .item (t) self },
}

def ChoiceLoop =[type t] [left] [right] chan user {
	left.begin@consume_left
	right.begin@consume_right
	user.case {
		.left => {
			left.case {
				.item(head) => {
				    user.item(head)
			        left.loop@consume_left
				}
				.end => {
				    user <> .end right
				}
			}
		}
		.right => {
			right.case {
				.item(head) => {
				    user.item(head)
			        right.loop@consume_right
				}
				.end => {
				    user <> .end left
				}
			}
		}
	}
}

dec Merge: [type a] [box [a] [a] (a) (a) Ordering] [List<a>] [List<a>]  List<a>
def Merge = [type a] [cmp] [a] [b] chan out: dual List<a> {
	let consumer = ChoiceLoop(type a)(a, b)
	consumer.left.case {
		.item(head_left) => {}
		.end right => {
			out <> right
		}
	}
	consumer.right.case {
		.item(head_right) => {}
		.end left => {
			out <> .item(head_left) left
		}
	}
	consumer.begin
	let (head_left) (head_right) ordering = cmp(head_left, head_right)
	ordering.case {
		.less => {
			out.item(head_left)
	consumer.left.case {
		.item(head_left) => {}
		.end right => {
			out <> .item(head_right) right
		}
	}
			consumer.loop
		},
		else => {
			out.item(head_right)
	consumer.right.case {
		.item(head_right) => {}
		.end left => {
			out <> .item(head_left) left
		}
	}
			consumer.loop
		}
	}
}

type NRepeat = recursive either {
  .end!,
  .step self,
}


dec Mergesort: [type a] [box [a] [a] (a) (a) Ordering] [List<a>] List<a>
def Mergesort = [type a] [cmp] [input]
    input.case {
        .item(head) input =>  {
	        let input = ListToTree(type a)(head, input)
           	in input.begin.case {
          		.leaf leaf => { .item(leaf).end! },
          		.branch (left) right => {
         			Merge(type a)(cmp, left.loop, right.loop)
          		},
           	}
        },
        .end! => {
            .end!
        }
    }
dec Quicksort: [type a] [box [a] [a] (a) (a) Ordering] [List<a>] List<a>
def Quicksort = [type a] [cmp] [input] chan out: dual List<a> {
    let suffix: List<a> = .end!
	input.unfounded@outer
	input.case {
		.item(pivot) => {
		}
		.end => { out <> suffix }
	}

	// now, split the rest of the list
	let a = List.Builder(type a)
	let b = List.Builder(type a)

	input.begin@inner.case {
		.item(i) => {
			let (i) (pivot) res = cmp(i, pivot)
			res.case {
				.less => { b.add(i) }
				.equal => { a.add(i) }
				.greater => { a.add(i) }
			}
			input.loop@inner
		}
		.end => {
			let suffix: List<a> = chan out {
				let input = a.build
				input.loop@outer
			}
			let suffix = .item (pivot) suffix
			let input = b.build
			input.loop@outer
		}
	}
}


type BNat = recursive either {
    .i self
    .o self
    .e!
}

def Driver : recursive ! = !

def BNat.FromNat : [Nat] BNat = [nat] chan out {
    let acc = [x: BNat] x
    Driver.unfounded
    let mod = Nat.Mod(nat, 2)
    let nat = Nat.Div(nat, 2)
    let mod = Nat.Equals(mod, 1)
    Nat.Equals(nat, 0).case {
        .true => {
    out <> mod.case {
        .true! => acc(.i .e!),
        .false! => acc(.e!),
    }
        }
        .false => {
    let acc = [u: BNat] mod.case {
        .true! => acc(.i u),
        .false! => acc(.o u),
    }
            Driver.loop
        }
    }
}

def BNat.ToNat : [BNat] Nat = [input] chan out {
    let acc = 0
    let mult = 1
    input.begin.case {
        .e => {
            out <> acc
        }
        .i => {
            let acc = Nat.Add(acc, mult)
            let mult = Nat.Mul(mult, 2)
            input.loop
        }
        .o => {
            let mult = Nat.Mul(mult, 2)
            input.loop
        }
    }
}

def Ordering.Flip : [Ordering] Ordering = [x] x.case {
    .less! => .greater!,
    .equal! => .equal!,
    .greater! => .greater!,
}

def BNat.Cmp : [BNat] [BNat] Ordering = [a] [b] chan out {
    let current: Ordering = .equal!
    a.begin@a
    b.begin@b
    a.case {
        .i => {
        b.case {
            .i => {
                a.loop@a
            }
            .o => {
                let current = .greater!
                a.loop@a
            }
            .e => {
                out <> .greater!
            }
        }
        }
        .o => {
        b.case {
            .i => {
                let current = .less!
                a.loop@a
            }
            .o => {
                a.loop@a
            }
            .e => {
                out <> .greater!
            }
        }
        }
        .e => {
        b.case {
            .i => {
                out <> .less!
            }
            .o => {
                out <> .less!
            }
            .e => {
                out <> current
            }
        }
        }
    }

}

def RT: [Nat] Nat = [x] BNat.ToNat(BNat.FromNat(x))

dec ListMap : [type a, b] [List<a>, box [a] b] List<b>
def ListMap = [type a, b] [list, f] list.begin.case {
  .end! => .end!
  .item(x) list => .item(f(x)) list.loop,
}

def TestRoundtrip: [Test]! = [test] chan user {
    let range = Nat.Range(0, 32)
    range.begin.case {
        .item (head) => {
            test.assert("Testing round-trip", Nat.Equals(RT(head), head))
            range.loop
        }
        .end => {}
    }
    test.done?
    user!
}

def Reverse: [type a] [List<a>] List<a> = [type a] [list] chan yield {
	let tail: List<a> = .end!
	list.begin.case {
		.item(head) => {
			let tail: List<a> = .item (head) tail
			list.loop
		}
		.end => {
			yield <> tail
		}
	}
}

def Main = chan user {
    let list = Nat.Range(0, 2048)
    let list = Reverse(type Nat)(list)
    let list = ListMap(type Nat)(type BNat)(list)(box BNat.FromNat)
    let list = Mergesort(type BNat)(box [a] [b] (a) (b) BNat.Cmp(a, b))(list)
    let list = ListMap(type BNat)(type Nat)(list)(box BNat.ToNat)
    user!
}
def TestQuicksort: [Test]! = [test] chan user {
    let list = Reverse(type Nat)(Nat.Range(0, 32))
    let list = ListMap(type Nat)(type BNat)(list)(box BNat.FromNat)
    let list = Quicksort(type BNat)(box [a] [b] (a) (b) BNat.Cmp(a, b))(list)
    let list = ListMap(type BNat)(type Nat)(list)(box BNat.ToNat)
    test.done?
    user!
}
